***************
Execution Model
***************

Slots, Variables, and Members
=============================

llvmPy distinguishes between two mechanisms for storing variables:

slot
    An array-indexed pointer in a lexical frame (on the stack or on the heap) to an object on the heap.

member
    Entry in a dynamic map-like structure that associates the name of the slot to the pointer of a heap object.

The emitter will generally strive to allocate as many variables in slots as possible, which is possible when the scope and name of a variable is lexically unambiguous (e.g. variables on the left-hand side of assign statements in function definitions). Where that is not possible (e.g. assigning a global variable of some other module), a variable is stored as a member. The uniqueness of names in a scope is maintained across its slots and members. The ``getattr(obj, name)`` and ``setattr(obj, name, value)`` builtins manage the mechanisms automatically.

Calling Convention
==================

Functions are represented by ``PyFunc`` objects, the contents of which include the function's bytecode address, an optional pointer to the method's class instance, and an optional pointer to a lexical scope generated by ``llvmPy_func()``.

Before the caller can jump to the function's address, it must call ``llvmPy_fchk()`` to verify that the calling convention it intends to use (based on the AST) is suitable for the callee. ::

    %callframe = alloca %Frame*
    %label = call i8* @llvmPy_fchk(%Frame** %callframe, %PyObj* %obj, i64 2)

In this example, the caller intends to call the function object ``%obj`` with two arguments, to which ``@llvmPy_fchk()`` will throw an error if there is a mismatch with the callee's signature. The resultant ``%label`` contains the function's address, and must first be bit-cast in accordance with the calling convention used. The contents of ``%callframe`` shall depend on the particular function:

    * If the function is a library function, ``%callframe`` is undefined.
    * If the function is a library method, the ``%callframe`` will contain a pointer to the object.
    * If the function is an user function, the ``%callframe`` is a pointer to the callee's lexical scope.
    * If the function is an user method, the ``%callframe`` is a pointer to a ``Call`` structure containing the caller's lexical scope as well as the object's self-pointer. In this situation the ``%label`` is not the callee itself, but rather an intermediate function with an equivalent signature that unpacks the call frame before delegating to the actual function.

If the function check does not throw, the label is called immediately: ::

    %func = bitcast i8* %label to %PyObj* (%Frame**, %PyObj*, %PyObj*)*
    %result = call %PyObj* %func(%Frame** %callframe, %PyObj* %arg1, %PyObj* %arg2)

