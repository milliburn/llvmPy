***************
Execution Model
***************

Calling Convention
==================

Functions are represented by ``PyFunc`` objects, the contents of which include the function's bytecode address, an optional pointer to the method's class instance, and an optional pointer to a lexical scope generated by ``llvmPy_func()``.

Before the caller can jump to the function's address, it must call ``llvmPy_fchk()`` to verify that the calling convention it intends to use (based on the AST) is suitable for the callee. ::

    %callframe = alloca %Frame*
    %label = call i8* @llvmPy_fchk(%Frame** %callframe, %PyObj* %obj, i64 2)

In this example, the caller intends to call the function object ``%obj`` with two arguments, to which ``@llvmPy_fchk()`` will throw an error if there is a mismatch with the callee's signature. The resultant ``%label`` contains the function's address, and must first be bit-cast in accordance with the calling convention used. The contents of ``%callframe`` shall depend on the particular function:

    * If the function is a library function, ``%callframe`` is undefined.
    * If the function is a library method, the ``%callframe`` will contain a pointer to the object.
    * If the function is an user function, the ``%callframe`` is a pointer to the callee's lexical scope.
    * If the function is an user method, the ``%callframe`` is a pointer to a ``Call`` structure containing the caller's lexical scope as well as the object's self-pointer. In this situation the ``%label`` is not the callee itself, but rather an intermediate function with an equivalent signature that unpacks the call frame before delegating to the actual function.

If the function check does not throw, the label is called immediately: ::

    %func = bitcast i8* %label to %PyObj* (%Frame**, %PyObj*, %PyObj*)*
    %result = call %PyObj* %func(%Frame** %callframe, %PyObj* %arg1, %PyObj* %arg2)
